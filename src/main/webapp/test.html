<div data-lift="AsciiDoctor">
  <div id="preamble">
  <div class="sectionbody">
    <div class="quoteblock abstract">
      <blockquote>
        <div class="paragraph">
          <p>Many members of the growing Scala community have immigrated in after years of Java development and are faced with a daunting learning curve to comprehen
            d the Scala type system.
            Most literature addressing type-level programming in Scala either begins with an assumption of a strong working knowledge of type theory, or quickly thrust
            s the reader into a sea of category-theory jargon.
            This article aims to teach the basics of type manipulation in Scala by meeting the audience where they are: developers who know how to write code to get a
            job done.</p>
        </div>
      </blockquote>
    </div>
  </div>
</div>
<div class="sect1">
  <h2 id="_value_level_programming">Value-Level Programming</h2>
  <div class="sectionbody">
    <div class="paragraph">
      <p>I am a big believer in the principle that you can only teach folks things which are near what they already understand.
        This behooves a teacher to establish an understanding of the audience under consideration.
        Since I am unable to engage this particular audience for feedback, I will instead work from a few open assumptions.
        For this discussion, I am assuming that the readers are solid programmers eager to expand their skill set to new levels.
        My audience members may not all be Scala developers, but are well-versed in Java and capable of quickly understanding the basics of Scala as needed.</p>
    </div>
    <div class="paragraph">
      <p>Furthermore, I also believe in first learning by examples, then later studying the patterns and abstractions which arise out of the initial cursory obse
        rvations.
        From my experience, this is how most universities teach computer science.
        We begin by playing with the chosen programming language, printing ``Hello World'' on the console and having fun long before we are confronted with the con
        cepts such as threads blocking for I/O, race conditions, mutability, etc.
        By no means do I wish to diminish the value of theory and forge a false dichotomy between the academic and the pragmatic.
        My intent is to first allow the reader to <em>play</em> with type programming in hopes that it fosters a genuine interest leading to further exploration.</
      p>
    </div>
    <div class="paragraph">
      <p>Before we dive into type-level programming, we need to first establish an understanding of its complement known as value-level programming.
        Let&#8217;s kick things off with a simple declaration of a value in Scala.</p>
    </div>
    <div class="listingblock">
      <div class="content">
        <pre class="highlight"><code class="language-scala" data-lang="scala">val num = 42</code></pre>
      </div>
    </div>
    <div class="paragraph">
      <p>I suspect most of my audience is aware of the heavy influence of functional programming on Scala and may already know that this means I&#8217;ve assigne
        d the value <code>42</code> to the name <code>num</code>, and it is <em>immutable</em>.
        Many folks will quickly point out that this value could also be declared as a <code>var</code>, allowing us to reassign the value of <code>num</code> at a
        later time.
        However, let&#8217;s not concern ourselves with the mutable counterpart for <code>val</code> in this discussion.</p>
    </div>
    <div class="paragraph">
      <p>What is important here is that we have assigned the value <code>42</code> to the name <code>num</code>.
        Also of acute interest is this value is assigned at the moment the runtime encounters this line of code.
        That is, the expression to the right of the equals sign is computed (trivially to the value of <code>42</code> in this case) and placed on the heap, and th
        e <code>num</code> reference is given this object&#8217;s address in memory.</p>
    </div>
    <div class="paragraph">
      <p>What you may not know is <code>val</code> and <code>var</code> are certainly not the only two declarations which can be made in Scala to bind an express
        ion to a name.
        If you have already spent some time in Scala, you are aware of how you can define a procedure/function/method.</p>
    </div>
    <div class="listingblock">
      <div class="content">
        <pre class="highlight"><code class="language-scala" data-lang="scala">def sayHello() = println("Hello World!")</code></pre>
      </div>
    </div>
    <div class="paragraph">
      <p>Now one cool thing here is a <code>def</code> does not require the name to be followed by a parenthetically-wrapped argument list.
        It is valid to drop it altogether when there are no arguments.
        For instance, we can have a one-liner which grabs a new <code>Date</code> object each time invoked.</p>
    </div>
    <div class="listingblock">
      <div class="content">
        <pre class="highlight"><code class="language-scala" data-lang="scala">def timestamp = new java.util.Date()</code></pre>
      </div>
    </div>
    <div class="paragraph">
      <p>Before I move along, if you are from a Java background and little-to-no Scala, then there are a few things I should point out.
        Firstly, the last line of a function body is <em>implicitly</em> returned, hence this function returns the new <code>Date</code> object.
        Secondly, Scala&#8217;s type inference allows us to omit the explicit return type.
        Hence a more-expanded version of this function which you may better understand is as follows:</p>
    </div>
    <div class="listingblock">
      <div class="content">
        <pre class="highlight"><code class="language-scala" data-lang="scala">def timestamp:java.util.Date = return new java.util.Date()</code></pre>
      </div>
    </div>
    <div class="paragraph">
      <p>There is a fourth declaration of values you can make which is of interest for this exposÎ˜: <code>lazy val</code>.
        This is much like <code>val</code> in that the expression computed for the value is immutable, but that expression is not calculated until the first time i
        t is asked for.
        It is <em>lazily</em> evaluated, much like that old <a href="http://stackoverflow.com/questions/18093735/double-checked-locking-in-singleton/">double-check
          ed locking singleton trick</a> we&#8217;ve been doing in Java since the updated 1.5 memory model made it not broken.</p>
    </div>
    <div class="paragraph">
      <p>So we have three interesting declarations of immutable values: <code>val</code>, <code>lazy val</code>, and <code>def</code>.
        Notice the fundamental difference among the three.
        The first is evaluated immediately when encountered at runtime.
        The second is not evaluated until later when it is first invoked (if it is <em>ever</em> invoked at all).
        The last is evaluated later after <em>every</em> invocation.
        These three are differentiated by <em>when</em> the declaration&#8217;s expression on the right is evaluated.
        Let&#8217;s take a quick look at all of these in action:</p>
    </div>
    <div class="listingblock">
      <div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">val iter = (1 to 4).iterator

  def def_i = iter.next() <b class="conum">(1)</b>
  lazy val lazy_i = iter.next() <b class="conum">(2)</b>
  val val_i = iter.next() <b class="conum">(3)</b>

  println(def_i)  // Prints 2
  println(lazy_i) // Prints 3
  println(val_i)  // Prints 1
  println(def_i)  // Prints 4
  println(lazy_i) // Prints 3
  println(val_i)  // Prints 1</code></pre>
      </div>
    </div>
    <div class="colist arabic">
      <ol>
        <li>
          <p><code>def_i</code> re-evaluates the expression on every invocation, returning a new value from <code>iter.next()</code>.</p>
        </li>
        <li>
          <p><code>lazy_i</code> evaluates the expression the first time we reference <code>lazy_i</code>, but retains that value for the remainder of the scope&#821
            7;s lifetime.</p>
        </li>
        <li>
          <p><code>val_i</code> evaluates when it is declared, assigning itself to the first value in our sequence</p>
        </li>
      </ol>
    </div>
    <div class="paragraph">
      <p>Lastly, note that all of these values are calculated at runtime to produce values.
        That is why this programming is often referred to as <em>value-level programming</em>.
        This is what we are all familiar with, as I&#8217;m certain everyone reading this has written a program which calculates values at runtime.</p>
    </div>
  </div>
</div>
<div class="sect1">
  <h2 id="_type_level_programming">Type-Level Programming</h2>
  <div class="sectionbody">
    <div class="paragraph">
      <p>Scala has a nice trick that is a bit of a throw-back to C.
        Whenever you have a type that you don&#8217;t want to repeat throughout your code base, you use a <code>typedef</code>.
        Similarly in Scala, you can declare a <code>type</code></p>
    </div>
    <div class="listingblock">
      <div class="content">
        <pre class="highlight"><code class="language-scala" data-lang="scala">type MyMap = Map[Int, String]</code></pre>
      </div>
    </div>
    <div class="paragraph">
      <p>Then within the scope of the type declaration of <code>MyMap</code>, we can use this type to avoid typing the longer, less attractive <code>Map[Int, Str
        ing]</code>.
        Java developers, rejoice!
        We can avoid repeating <a href="https://twitter.com/yanaga/status/484422344174473216/">HTML-style types</a> like <code>List&lt;Map&lt;String, Map&lt;String
          , List&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt;&gt;&gt;&gt;</code> where all of those <a href="https://twitter.com/richardswalker/status/4818253
71315507200/">angle brackets can cut you</a>.</p>
    </div>
    <div class="paragraph">
      <p>Pop quiz!
        When does the expression on the right of the equal sign get evaluated for a type declaration?
        At compile-time, of course.
        The compiler takes note of this declaration, and essentially replaces every occurrence of <code>MyMap</code> with <code>Map[Int, String]</code>
        (<em>Disclaimer</em>: I don&#8217;t know this is <em>really</em> what happens in the compiler, because I don&#8217;t know jack about what that magic black
        box does).
        In a nut-shell, this is <em>type-level programming</em>;  evaluating expressions at compile-time.</p>
    </div>
    <div class="paragraph">
      <p>We can think of the <code>type</code> declaration just as the earliest of all of the declarations we can do, because <code>val</code>, <code>lazy val</c
        ode>, and <code>def</code> aren&#8217;t evaluated until runtime.
        Also just like those three, a <code>type</code> declaration can be evaluated from an expression containing other types to form a final type that is more in
        teresting than just a name replacement.
        What is very interesting about Scala&#8217;s types in particular is the type system itself is Turing-complete.
        The logical difference between value-level programming and type-level programming can be thought of as merely syntactic.
        Both can compute the sorts of expressions we all know and love.
        It&#8217;s just a matter of <em>when</em> they are computed.</p>
    </div>
    <div class="sect2">
      <h3 id="_booleans_as_values">Booleans as Values</h3>
      <div class="paragraph">
        <p>Let&#8217;s begin by studying the simplest domain a student of software would know: Boolean algebra.
          First we will implement it as values, then examine how the same logic can be implemented as types.
          We will define a Boolean trait (loosely equivalent to an interface in Java) and True/False objects
          (loosely equivalent to a &#8230;&#8203; well, Java doesn&#8217;t have these.
          Think of them as singletons for this discussion).</p>
      </div>
      <div class="listingblock">
        <div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">sealed trait BoolVal <b class="conum">(1)</b>

  case object TrueVal extends BoolVal
  case object FalseVal extends BoolVal</code></pre>
        </div>
      </div>
      <div class="colist arabic">
        <ol>
          <li>
            <p>The <code>sealed</code> keyword guarantees that the only types which extend <code>BoolVal</code> are defined in the current file.</p>
          </li>
        </ol>
      </div>
      <div class="paragraph">
        <p>We can easily see that we satisfy the first property of Boolean values we&#8217;ve come to expect in that there are only two values in existence.<span c
                                                                                                                                                                  lass="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span>
          Because we&#8217;re utilizing case objects, we also get the equality properties of Boolean algebra satisfied as the following <a href="http://scalatest.org
/">ScalaTest</a> code demonstrates:</p>
      </div>
      <div class="listingblock">
        <div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">class BoolValSpecs extends WordSpec with ShouldMatchers {
  "FalseVal" should {
  "equal itself" in { FalseVal should equal (FalseVal) }
  "not equal TrueVal" in { FalseVal should not equal (TrueVal) }
  }

  "TrueVal" should {
  "equal itself" in { TrueVal should equal (TrueVal) }
  "not equal FalseVal" in { TrueVal should not equal (FalseVal) }
  }
  }</code></pre>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="sect1">
  <h2 id="_bibliography">Bibliography</h2>
  <div class="sectionbody">
    <div class="paragraph">
      <p>Much thanks for the inspiration for the content of the article is owed to the following blog posts by Mark Harrah.</p>
    </div>
    <div class="ulist bibliography">
      <ul class="bibliography">
        <li>
          <p>Harrah, Mark. 2010. ``Type-Level Programming in Scala, Part 3: Boolean.'' Accessed July 12. <a href="http://apocalisp.wordpress.com/2010/06/13/type-leve
l-programming-in-scala-part-3-boolean/" class="bare">http://apocalisp.wordpress.com/2010/06/13/type-level-programming-in-scala-part-3-boolean/</a>. (1)</p>

        </li>
        <li>
          <p>Harrah, Mark. 2010. ``Type-Level Programming in Scala, Part 4a: Peano number basics'' Accessed July 12. <a href="http://apocalisp.wordpress.com/2010/06/
16/type-level-programming-in-scala-part-4a-peano-number-basics/" class="bare">http://apocalisp.wordpress.com/2010/06/16/type-level-programming-in-scala-par
            t-4a-peano-number-basics/</a>. (2)</p>
        </li>
      </ul>
    </div>
  </div>
</div>
<div class="sect1">
  <h2 id="_about_the_author">About the Author</h2>
  <div class="sectionbody">
    <div class="paragraph">
      <p><a href="joescii-bio.adoc" class="bare">joescii-bio.adoc</a></p>
    </div>
  </div>
</div>
<div id="footnotes">
  <hr>
  <div class="footnote" id="_footnote_1">
    <a href="#_footnoteref_1">1</a> More correctly, Boolean algebra is not limited to only two values, but it contains two unique values which satisfy some giv
    en properties. Just for the sake of this discussion, I am allowing a looser definition of the theory.
  </div>
</div>
</div>
