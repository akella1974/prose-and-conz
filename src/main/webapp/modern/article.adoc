= Type-Level Programming in Scala 101: Computation at _Compile_ _Time_
Joe Barnes <barnesjd@gmail.com>
:css-signature: nfjsmag-v6.5-joescii
:hashtag: Scala
:keywords: Scala, static typing
:description: This article invites the reader to play with the static type system in Scala without the theory that typically entangles a beginner.
:published: 2014-12-26T05:00:00-0600
:updated: 2014-12-26T05:00:00-0600
ifndef::codedir[:codedir: code]
ifndef::imagesdir[:imagesdir: images]

[abstract]
--
Many members of the growing Scala community have immigrated in after years of Java development and are faced with a daunting learning curve to comprehend the Scala type system.
Most literature addressing type-level programming in Scala either begins with an assumption of a strong working knowledge of type theory, or quickly thrusts the reader into a sea of category-theory jargon.
This article aims to teach the basics of type manipulation in Scala by meeting the audience where they are: developers who know how to write code to get a job done.
--

== Value-Level Programming

I am a big believer in the principle that you can only teach folks things which are near what they already understand.
This behooves a teacher to establish an understanding of the audience under consideration.
Since I am unable to engage this particular audience for feedback, I will instead work from a few open assumptions.
For this discussion, I am assuming that the readers are solid programmers eager to expand their skill set to new levels.
My audience members may not all be Scala developers, but are well-versed in Java and capable of quickly understanding the basics of Scala as needed.

Furthermore, I also believe in first learning by examples, then later studying the patterns and abstractions which arise out of the initial cursory observations.
From my experience, this is how most universities teach computer science.
We begin by playing with the chosen programming language, printing ``Hello World'' on the console and having fun long before we are confronted with the concepts such as threads blocking for I/O, race conditions, mutability, etc.
By no means do I wish to diminish the value of theory and forge a false dichotomy between the academic and the pragmatic.
My intent is to first allow the reader to _play_ with type programming in hopes that it fosters a genuine interest leading to further exploration.

Before we dive into type-level programming, we need to first establish an understanding of its complement known as value-level programming.
Let's kick things off with a simple declaration of a value in Scala.

[source,scala]
----
val num = 42
----

I suspect most of my audience is aware of the heavy influence of functional programming on Scala and may already know that this means I've assigned the value `42` to the name `num`, and it is _immutable_.
Many folks will quickly point out that this value could also be declared as a `var`, allowing us to reassign the value of `num` at a later time.
However, let's not concern ourselves with the mutable counterpart for `val` in this discussion.

What is important here is that we have assigned the value `42` to the name `num`.
Also of acute interest is this value is assigned at the moment the runtime encounters this line of code.
That is, the expression to the right of the equals sign is computed (trivially to the value of `42` in this case) and placed on the heap, and the `num` reference is given this object's address in memory.

What you may not know is `val` and `var` are certainly not the only two declarations which can be made in Scala to bind an expression to a name.
If you have already spent some time in Scala, you are aware of how you can define a procedure/function/method.

[source,scala]
----
def sayHello() = println("Hello World!")
----

Now one cool thing here is a `def` does not require the name to be followed by a parenthetically-wrapped argument list.
It is valid to drop it altogether when there are no arguments.
For instance, we can have a one-liner which grabs a new `Date` object each time invoked.

[source,scala]
----
def timestamp = new java.util.Date()
----

Before I move along, if you are from a Java background and little-to-no Scala, then there are a few things I should point out.
Firstly, the last line of a function body is _implicitly_ returned, hence this function returns the new `Date` object.
Secondly, Scala's type inference allows us to omit the explicit return type.
Hence a more-expanded version of this function which you may better understand is as follows:

[source,scala]
----
def timestamp:java.util.Date = return new java.util.Date()
----

There is a fourth declaration of values you can make which is of interest for this expos√©: `lazy val`.
This is much like `val` in that the expression computed for the value is immutable, but that expression is not calculated until the first time it is asked for.
It is _lazily_ evaluated, much like that old http://stackoverflow.com/questions/18093735/double-checked-locking-in-singleton/[double-checked locking singleton trick] we've been doing in Java since the updated 1.5 memory model made it not broken.

So we have three interesting declarations of immutable values: `val`, `lazy val`, and `def`.
Notice the fundamental difference among the three.
The first is evaluated immediately when encountered at runtime.
The second is not evaluated until later when it is first invoked (if it is _ever_ invoked at all).
The last is evaluated later after _every_ invocation.
These three are differentiated by _when_ the declaration's expression on the right is evaluated.
Let's take a quick look at all of these in action:

[source,scala]
----
val iter = (1 to 4).iterator

def def_i = iter.next() // <1>
lazy val lazy_i = iter.next() // <2>
val val_i = iter.next() // <3>

println(def_i)  // Prints 2
println(lazy_i) // Prints 3
println(val_i)  // Prints 1
println(def_i)  // Prints 4
println(lazy_i) // Prints 3
println(val_i)  // Prints 1
----
<1> `def_i` re-evaluates the expression on every invocation, returning a new value from `iter.next()`.
<2> `lazy_i` evaluates the expression the first time we reference `lazy_i`, but retains that value for the remainder of the scope's lifetime.
<3> `val_i` evaluates when it is declared, assigning itself to the first value in our sequence

Lastly, note that all of these values are calculated at runtime to produce values.
That is why this programming is often referred to as _value-level programming_.
This is what we are all familiar with, as I'm certain everyone reading this has written a program which calculates values at runtime.

== Type-Level Programming

Scala has a nice trick that is a bit of a throw-back to C.
Whenever you have a type that you don't want to repeat throughout your code base, you use a `typedef`.
Similarly in Scala, you can declare a `type`

[source,scala]
----
type MyMap = Map[Int, String]
----

Then within the scope of the type declaration of `MyMap`, we can use this type to avoid typing the longer, less attractive `Map[Int, String]`.
Java developers, rejoice!
We can avoid repeating https://twitter.com/yanaga/status/484422344174473216/[HTML-style types] like `List<Map<String, Map<String, List<Map<String, Map<String, Object>>>>>>` where all of those https://twitter.com/richardswalker/status/481825371315507200/[angle brackets can cut you].

Pop quiz!
When does the expression on the right of the equal sign get evaluated for a type declaration?
At compile-time, of course.
The compiler takes note of this declaration, and essentially replaces every occurrence of `MyMap` with `Map[Int, String]`
(_Disclaimer_: I don't know this is _really_ what happens in the compiler, because I don't know jack about what that magic black box does).
In a nut-shell, this is _type-level programming_;  evaluating expressions at compile-time.

We can think of the `type` declaration just as the earliest of all of the declarations we can do, because `val`, `lazy val`, and `def` aren't evaluated until runtime.
Also just like those three, a `type` declaration can be evaluated from an expression containing other types to form a final type that is more interesting than just a name replacement.
What is very interesting about Scala's types in particular is the type system itself is Turing-complete.
The logical difference between value-level programming and type-level programming can be thought of as merely syntactic.
Both can compute the sorts of expressions we all know and love.
It's just a matter of _when_ they are computed.

=== Booleans as Values

Let's begin by studying the simplest domain a student of software would know: Boolean algebra.
First we will implement it as values, then examine how the same logic can be implemented as types.
We will define a Boolean trait (loosely equivalent to an interface in Java) and True/False objects
(loosely equivalent to a ... well, Java doesn't have these.
Think of them as singletons for this discussion).

[source,scala]
----
sealed trait BoolVal // <1>

case object TrueVal extends BoolVal
case object FalseVal extends BoolVal
----
<1> The `sealed` keyword guarantees that the only types which extend `BoolVal` are defined in the current file.

We can easily see that we satisfy the first property of Boolean values we've come to expect in that there are only two values in existence.footnote:[More correctly, Boolean algebra is not limited to only two values, but it contains two unique values which satisfy some given properties. Just for the sake of this discussion, I am allowing a looser definition of the theory.]
Because we're utilizing case objects, we also get the equality properties of Boolean algebra satisfied as the following http://scalatest.org/[ScalaTest] code demonstrates:

[source,scala]
----
class BoolValSpecs extends WordSpec with ShouldMatchers {
  "FalseVal" should {
    "equal itself" in { FalseVal should equal (FalseVal) }
    "not equal TrueVal" in { FalseVal should not equal (TrueVal) }
  }

  "TrueVal" should {
    "equal itself" in { TrueVal should equal (TrueVal) }
    "not equal FalseVal" in { TrueVal should not equal (FalseVal) }
  }
}
----

////
The comment block below shows the minimum syntax needed to include a figure or image.

.Caption of image or figure
image::filename.extension[]
////

[bibliography]
== Bibliography

Much thanks for the inspiration for the content of the article is owed to the following blog posts by Mark Harrah.

[bibliography]
- Harrah, Mark. 2010. ``Type-Level Programming in Scala, Part 3: Boolean.'' Accessed July 12. http://apocalisp.wordpress.com/2010/06/13/type-level-programming-in-scala-part-3-boolean/. (1)
- Harrah, Mark. 2010. ``Type-Level Programming in Scala, Part 4a: Peano number basics'' Accessed July 12. http://apocalisp.wordpress.com/2010/06/16/type-level-programming-in-scala-part-4a-peano-number-basics/. (2)

== About the Author

